### Java Basics ### 
    
    -Bitwise Operators : perform manipulation of individual bits of a number. They can be used with any of the integer types.
    	&       Bitwise AND			 (true only all cases are true (1 & 1))
    	^       Bitwise exclusive OR (true when one case is true (1^0 || 0^1) and false in the rest (1^1 || 0^0))
    	|       Bitwise inclusive OR (true in all cases except when all cases are false (0 | 0))
    -The | and & operators, when applied to boolean operands, ensure that both the sides are evaluated. This is opposed to || and && operators, 
        which do not evaluate the Right Hand Side operand if the result can be known by just evaluating the Left Hand Side.
    -Shift Operators : shift the bits of a number left or right thereby multiplying or dividing the number by two respectively.
        They can be used when we have to multiply or divide a number by two
    	    ~ (Unary Bitwise Complement): Inverts bits. (~2 = -3).
            << (Signed Left Shift): Multiplies by two. (2 << 1 = 4).
            >> (Signed Right Shift): Divides by two, preserving the sign. (2 >> 1 = 1).
            >>> (Unsigned Right Shift): Divides by two, filling left bits with zero. (2 >>> 1 = 1).

    -Constants in Switch Cases: Value of switch cases should be a constant, literal value, or final variable.
    - "=" has least precedence of all operators
    -Array Initializer Block: 
        -Cannot specify length when using an initializer block : new String[3]{ "a", "b", "c"} 
        -Cannot specify the size on left hand side : int i[4] = { 1, 2, 3, 4 } ;
        -var i = { { 1, 2 }, new int[ 2 ] } ; // not valid : int[][] is required on the right side.
            -Pay attention to missing commas when initializing a 2D array.
        -Valid array initialization:
            int[] arr = {1, 2};
            int[][] arr2 = {arr, {1, 2}, arr};
            int[][][] arr3 = {arr2};
            int i[ ][ ] = { { 1, 2 }, new int[ 2 ] } ;

    -Division by Zero in Java: Integral division by zero throws ArithmeticException, while floating-point division results in POSITIVE_INFINITY or NEGATIVE_INFINITY.
    -if(x % 3 == 0) : checks multiples of x (divisible without a reminder)
    - && checks if lefthand operand is false, || checks if lefthand operand is true. Both will not check the right operand
    -var[] is invalid 
    -pay attention when an object has or has not time zone informations when formatting or casting
    -Optional.orElseGet() and orElse() don't throw an exception.
    -Optional.of() throws a NullPointerException if the passed value is null.
    -Left operand of instanceof must be an object, not primitives.
    -You can compare unequal primitives double == Short, int == Long.
    -long, float, boolean, double CANNOT be used as switch variable
    -pay attention to using string for 128 value, byte's range is -128 to 127.
    -new Object[]{ "aaa", new Object(), new ArrayList(), {} }; // {} is not valid
    -new Object[]{ "aaa", new Object(), new ArrayList(), new String[]{""} };  // is valid


    OOP :

        -Instance initialization order : class static fields, static intializers, instance fields, instance initializers, constructors
        -this(params) can only be called in a constructor and that too as a first statement, and not in a method
        -Inner Class Instantiation: An inner class requires an instance of its outer class for instantiation, e.g., new OuterClass().new InnerClass()
            or via an outer class instance.
        -Inheritance of Constructors: If a parent class only declares an args constructor, the child must explicitly declare a constructor with super().
        -Static and Instance Initializers: Both can access static variables.
        -The compiler does not provide the default no-args constructor if the programmer provides any other constructor for the class.
        -An overriding method cannot throw an exception that is a super class of the exception thrown by the overridden method.  But can not throw an exception at all.
        -If a class extends an abstract class and implements an interface, each with a static nested class of the same name, there is no conflict. 
            These nested classes are distinguished by their outer class or interface names. Access is to the abstract class's nested class, not the interface's.
        -Accessing a static field of a superclass doesn't trigger initialization of it's child class or it's constructor
        -Static methods are never overriden (but hidden) because they are not inherited like instance methods, they belong to their classes
        -Immutable Classes: Must be non-extendable outside the class declaration, and their data cannot be modified by the caller.
        -Sealed Classes/Interfaces: 
                -Must have a permits clause (unless nested : It is ok for a nested sealed class to omit the permits clause.)
                -All subclasses of a sealed class must belong to the same module (or to the same package if the sealed class is not a part of a named module).
                    even if a sealed class is visible outside a module, it cannot be extended by classes of other modules.
                -sealed and non-sealed keywords can comme before or after public/private ..
                -non sealed classes MUST extend sealed permitting class
        -an Inherited classes' Constructor cannot be private (constructor of super class has to be called via super())
        -A class implements Comparable interface when it wants to let an object of that class to be compared with another object of that class. A Comparable = "natural" ordering of objects of that class.
            When a class implements Comparable, you can sort a collection (or array) of objects of that class using Collections.sort (or Arrays.sort) without requiring a separate Comparator object.
        -compareTo(Obj obj) takes only one argument -> Comparable interface method
        -A extends B, so a A is-a B
        -According to the rule of covariant returns, an overriding method must return either the same type or a subtype of the type returned by the overridden method. 
            -primitives must be the same
        -A local variable needs to be final or effectively final to be accessed from an INNER CLASS OR lambda expression.
        -A virtual call : a call is bound to a method at runtime and not at compile time. All non-private and non-final instance method calls are virtual.
        -instanceof :
             A pattern variable is not allowed to shadow a local variable: A a = null; if(c instanceof A a ) // failure to compile
             null instanceof Object a = false
        -Anonymous classes are implicitly final and never static.    
        -You cannot override a final method.
        -this.staticField is valid
        -State vs Type : 
            -Interfaces, classes, enum = types (mutliple inheritance of type allowed)
            -Instance fields = state (only one inheritance of state)
    --possible to instanciate a nested static class using new OuterClass.StaticNested()
        -Instance methods can access both static and non-static methods.
        -DecimalFormat has no constructor that takes a Locale :
             Use NumberFormat.getCurrencyInstance(locale) 
             or DecimalFormat.getCurrencyInstance(locale)
        -Locale and Resource Bundles: If a matching key is not found in the specified bundle, the default locale bundle is used.
    GC : 
        1. An object can be made eligible for garbage collection by making sure there are no references pointing to that object.
        2. You cannot directly invoke GC. You can suggest the JVM to perform garbage collection by calling System.gc(); no guarantee for execution
        3. Objects pointed to by static variables of a class are not collected even when all objects of that class are collected because they belong 
            to the class (and not to the instance of the class). They are GCed only when the class itself is unloaded by the class loader.
        -obj = null will make it eligible to GC, obj.name = null is not needed in this case

    Generics : 
        -Generic Wildcards: Cannot occur on the right side of assignments. 
            Wildcards are not concrete types and cannot be used to instantiate objects. They are used in type declarations for flexibility, allowing for various kinds of type relationships.
        -List<?> is same as List<? extends Object> : A List containing instances of some class that extends Object class.
        -Type Bounds in Generics: "? super Number" means "a super-type of Number" (e.g., Object and Number).
        -Must use a type without bounds while instantiating : new ArrayList<? super Number>() is invalid, new ArrayList() is OK ( all type information are removed : type erasure)
        -Wildcards (?) are used for declaring variables, parameters, and return types, but they are not used in actual object creation (instantiation).
        -? wildcard is valid on the right while instantiating but not on the left:
            HashMap<?, List<String>> box = new HashMap<String, List<String>>(); // invalid
    String : 
        -String str = null; String newStr = "a " + str; => "a null"
        methods() :  
             -String substring(int beginInclusiveIndexFrom0) = "Hello World".substring(6); from W = "World"
             -String substring(int beginInclusiveIndexFrom0, int endExclusiveIndex) : "Hello World".substring(0, 5) = "Hello" 01234  
             -int indexOf(int ch, int fromIndex) = Returns the index of the first occurrence of the specified character, starting the search at the specified index. 
             -String.append() doesn't exist
             -StringBuilder append(CharSequence s, int start, int end)
             -StringBuilder insert(int dstOffset, CharSequence s, int start, int end)
             -StringBuilder replace(int start, int end, String str)
             -StringBuilder has sb.ensureCapacity(capacityInt) to at least have capacityInt chars

    Serialization : 
        Constructor and Initializers During Deserialization:
            -Class constructors and instance initializers are not called.
            -Fields not in the serialized file are set to default values (numbers to 0, booleans to false, objects to null).
            -Non-serializable superclass fields are initialized via its no-args constructor and instance initializers.
        serialVersionUID:
            -Represents the class version number; crucial for serialization compatibility.
            -Automatically generated if not specified, based on class attributes like fields and interfaces.
            -Used during deserialization to verify class compatibility. Mismatch results in InvalidClassException.
         Handling of Fields During Deserialization:
            -Fields present in the serialized object but not in the class are ignored.
            -Additional fields in the class (not in serialized object) are set to default values.
            -If serialVersionUID matches, deserialization completes successfully.
        Superclass Behavior:
            -If a superclass is not serializable, its constructor is called during deserialization.


###  DateTime API ### 

    -Timezones : Substracting hours from  -GMT timezone is equivalent to adding them (at 9:00 -6GMT = 9 + 6hours = 15:00 GMT)
    -Period affects only the date component and doesn't alter time, whereas Duration can impact the time component, 
        particularly around Daylight Saving Time (DST) transitions.    
    -LocalDate.plus(Period.of(0, 1, 1)) adds 1 month and 1 day. Period.of(int year, int months, int days). LocalDate.plus(Period.ofMonths(1).ofDays(1)) will add only 1 day.
    -Duration (PT) does not convert hours into days (25 hours will remain as 25 hours instead of 1 day and 1 hour) PT25H (Duation : HoursMinutesSeconds)
    -Duration of 0 is printed as 0S and a Period of 0 is printed as 0D.
    -DateTimeFormatter.ofPattern("eeee"); eeee is day of week (Monday)
        less than 4 pattern letters will use the short form. Exactly 4 pattern letters will use the full form. Exactly 5 pattern letters will use the narrow form. more than 5 times it will thrown an exception. 
    -Instant's truncatedTo() can take only ChronoUnit Days and lower (half days, hours, seconds..)
        : Instant.ofEpochSecond(1945820820).truncatedTo(ChronoUnit.DAYS) truncates to the start of the day in UTC & zeroes out the hours minutes seconds : 2031-08-30T00:00:00Z
    -'Z' suffix in datetime is Zulu time = UTC timezone
    -All the three printlns will produce 2022-02-05 (yyyy-MM-dd)
        LocalDate d1 = LocalDate.parse("2022-02-05", DateTimeFormatter.ISO_DATE);
        LocalDate d2 = LocalDate.of(2022, 2, 5);
        LocalDate d3 = LocalDate.now();

###  Interfaces ### 
        -Any field in an interface is implicitly public, static, and final, whether these keywords are specified or not.
        -Fields on an Interface must always be initialized.
    Inheritance:
        -Inheriting ambiguous fields or methods doesn't cause issues unless referred to ambiguously, which leads to compile-time errors.
        -Interfaces can extend other interfaces.
        -An interface can extend from any number of interfaces: interface A extends B, C, D.
        -pay attention to interface "implement" X: invalid only extends that's valid
    Method Specifications:
        -Only methods of an interface can be private. Private/protected fields are not allowed.
        -Static Interface Methods cannot call default, abstract, or non-static private interface methods.
        -Static methods can never be abstract (neither in an interface nor in a class).
        -An interface default and static method must have a body.
        -Private methods are not inherited.
    Method Redefinition and Overriding:
        -An interface can redeclare a default method and provide a different implementation or make it abstract.
        -A default method cannot be overridden by a static method. (A default method is a non-static method.)
        -You cannot override a non-static method with a static method and vice versa.

### Collections and Data Structures ### 

    -HashMap vs Hashtable: HashMap allows both key and value to be null, unlike Hashtable.
    -Hashset allows null values
    -An abstract class is allowed not to implement any methods of an implemented interface.
    -List.subList method returns a view backed by the original list. It doesn't change the existing list.
    	But if you modify the subList, the changes will be visible in the original list.
    -NavigableMap extends SortedMap to provide navigation methods, used to navigate the map in both ascending and descending key order.
    -Pay attention to what stream() methods return, is it an intermediate method followed by nothing, is filter() called after xMatch() ?
    -steam().peak(consumer) : performs an action on the elements of the stream :
        it expects a consumer lambda like peek(System.out::println), must be used with terminal operation or it will do nothing.
    -flatMap is used when each element of a given stream can itself generate a Stream of objects. 
        It's used to extract the elements of each of those individual streams and return a stream that contains all those elements.
    -Summary statistics is an object that contains the computation of count, min, max, sum, and average.
    -Queue is a FIFO structure (add to the end - remove from the front)
     	offer(e)/add(e)  add an element to the end or tail
    	poll()/remove() remove an element from the front or head
    -Stack is a LIFO structure (add to the front - remove from the front)
     	push(e) push adds to the front
    	pop() removes from the front.First
    -Collections.unmodifiableList creates an unmodifiable view of the underlying list, restricting add/remove operations on the view. 
        However, modifications to the original list are reflected in this view.
    -Collectors.joining(delim, prefix, suffix) returns a Collector that joins all the Strings in the given Stream separated by comma and then prefixes and suffixes the resulting String
    -average() method actually returns an OptionalDouble (and not Double).
    -Arrays.compare(a, b) dictionnary order = 0 if equal, 1 if a > b, -1  
    -HashMap.merge(k, v, biFunction remappingFunction) takes a BiFunction not a Function
    -reduce takes either :
        -binaryOperator
        -identity, binaryOperator
        -indentity, biFunction accumulator, binaryOperator combiner
    -Collection.sort modifies the original list that it's called on.
    -TreeMap keys must be comparable; cannot add String and Double as keys in a generic TreeMap.



### Functional/Lambda

    -Local variables referenced from a lambda expression must be final or effectively final
    -Abstract Method Source: The abstract method in a functional interface can be declared in the interface itself or a super interface.
    -Method Constraints: No constraints on parameter types or return type. The interface may contain other default or static methods.
    -Single Abstract Method Requirement: The core requirement is having exactly one abstract method.
    -a lambda expression does not create a new scope for variables validateEmployee(e, e->e.age<10000) must be validateEmployee(e, x -> x.age <10000) (e still in scope)
    -Stream can be sorted with stream().sorted()    
    -stream.count() returns a long
    -Pay attention to FunctionalInterfaces input type String, Integer, and if applicable on a List<Type>.
    -Pay attention to predicate condition on takeWhile and dropWhile the stream may contain 0 elements.
    -Stream().mapToDouble returns a DoubleStream instead of Stream<Double>. 
        Use a DoubleBinaryOperator instead of BinaryOperator<Double> for reduction


### Exception Handling ### 

    -Try-Catch-Finally Behavior: If finally throws an exception, other exceptions thrown in catch clauses will be ignored.
    -Try-with-Resources Statement: A resource must be marked final or be effectively final.
    -Catch Block Exceptions: Exceptions thrown by a catch cannot be caught by subsequent catch blocks in the same method.
    -Exceptions don't enhance security by reporting errors; they improve code by clearly separating error handling code from the app's main logic.
    -The exception parameter in a multi-catch clause is implicitly final.
    -An overriding method can only throw either the checked exceptions (and their subclasses) listed in the throws clause of the overridden method or decide not to throw any exception at all. 
    -IException is a subclass of Exception. You cannot include classes that are related by inheritance in the same multi-catch block.
    -Catch and finally blocks are executed after the resource opened in try-with-resources is closed.
    -Pay attention to unreachable code in try-catch-finally 
    -No need to catch RuntimeExceptions (like IndexOutOfBoundsException)
    -Exceptions thrown by AutoCloseable's close() are added to the original exception as suppressed exceptions.
    -if finally throws an exception (always last) it will be the one thrown by the code block or method
    -Exception thrown by a catch cannot be caught by the following catch blocks at the same level.
    -Unchecked vs. Checked Exceptions:
        Unchecked Exceptions (e.g., RuntimeException, Error subclasses) don't need to be caught explicitly.
        Checked Exceptions must be caught or declared; failure to handle them leads to a compilation error.
    -Optional Class Methods:
        Optional.of(): Throws NullPointerException if the argument is null.
        Optional.ofNullable(): Returns an empty Optional for null arguments.
        optional.orElse() and optional.orElseGet(): Provide fallback mechanisms.
    -DateTimeException extends RuntimeException, so it need not be caught or declared in the throws clause.
    -Errors are usually thrown due to resource constrains encountered by the JVM. They do not necessarily indicate a programming bug.
    -RuntimeExceptions should be identified during testing and eliminated by fixing the code, while Errors should be eliminated by fixing the environment.
    -Constructor must declare all the checked exceptions declared in the base constructor (or the super classes of the checked exceptions). 
        They may add other exceptions as well. This behavior is exactly opposite from that of methods. 
        The overriding method cannot throw any checked exception other than what the overridden method throws. It may throw subclasses of those exceptions as well.
    -If both catch and finally block throw an exception. The exception thrown by the finally block is the one that is thrown from the method. 
        The catch exception is lost and not added to the suppressed exceptions list of the exception thrown from the finally block.



### Records  ###
    Location & Nature:
        -Can be top-level, nested (implicitly static), or local (within a method).
        -Cannot be abstract, sealed, or non-sealed. It is always final.
        -can implement a method that has a getter like the interface abstract method.
        -cannot extend Record
        -can implement interfaces
        -Serialization uses canonical constructor.

    Structure Restrictions:
        -Static fields and initializers are allowed
        -Record fields can be set only once by the canonical constructor
        -No instance fields or instance initializers
        -No abstract or native methods.
        -Immutability of a record doesn't extend to the content of an Object of 
            record Student(int id, Person person). id and Person are immutable, but the content of Person is not.

    Constructors & Methods:
        -No setters (records are immutable)
        -Non-canonical constructors must call the canonical constructor or another constructor first.
        -Canonical constructor can be regular or compact form but cannot be generic or have a throws clause; non-canonical constructors can.
        -Cannonical constructor mainly used for validation
        -Accessor methods can't throw exceptions.
        -Additional methods are allowed, similar to regular classes.
        -Record  can't declare Object class methods like clone, finalize, getClass, notify, notifyAll, or wait
            Can override equals, hashCode, toString
        -A programmer may provide the canonical constructor in regular form or in a "compact form" like this:

        public record Student(int id, String name){
            public Student{ //no parameter list is specified here
            if(id <0) throw new IllegalArgumentException();
            }
        }

       -Important : If you write a non-canonical constructor in a record explicitly then, on the first line of such a constructor, you must provide a call to either the canonical constructor or another constructor.

        public record Student(int id, String name){
            public Student(){ // a non-canonical constructor
                this(10); // Required call
            }
            public Student(int id){ // another non-canonical constructor
                this(id, ""); // Required call
            }
            public Student(int id, String name){ // canonical constructor (redundant)
                this.id = id; this.name=name;
            }
        }


### NIO ### 

    -Path.resolve() : path.resolve(path2) : combines two paths
    	absolute path then path2 is used (overrides the original)
    	relative path (f it doesn't start with a root such as c: or / on linux)) then both paths are combined (appends to the original)
    	empty path "" the original path is used
    -Path is "c:\\code\\java\\PathTest.java",
    	p1.getRoot()  is c:\  ((For Unix based environments, the root is usually / ).
    	p1.getName(0)  is code
    	p1.getName(1)  is java
    	p1.getName(2)  is PathTest.java
    	p1.getName(3)  will cause IllegalArgumentException to be thrown.
    -Files.move/copy are static utility methods that do not return a resource that needs to be closed. They cannot be used with try-with-resources
    -A Reader such as a FileReader provides only low level operations such as reading a single character or array of characters.
    	BufferedReader "decorates" Reader to provide higher level method readLine() by buffering characters.
    	It is an efficient way of reading characters, character arrays, and lines. The same relationship exists between FileWriter and BufferedWriter but for writing.   
    
    System.Console : 
        -methods : format(), printf(), reader(), writer(), readPassword, readLine()
        -Call to System.console() doesn't throw any exception. It just returns null if Console is not available.
        -System.console() returns null if it's not available (code run in the background), so console.anyMethod() throws NPE.

    -path1.resolveSibling(path2) : replaces the filename portion of the first path with the entire second path to create a new path
    -file.mkdirs() will create also non existing parent directories
    -NoSuchFileException is thrown when Files.delete(path); is executed and the file it is attempting to delete is non existing
    -A BufferedReader can wrap any Reader (like FileReader and BufferedReader)
    -The size in bytes of a character depends on the default character encoding of the underlying platform.
    -Files.newDirectoryStream(Path dir, String globPattern) :
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, "*.txt"))  // "*.txt" : only text files
        try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir, "*.{gif,jpeg}")) // "*.{gif,jpeg}" : gif & jpeg files   
        try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir, "?.txt"))  // "?" Matches exactly one character : matches a.txt, but not ab.txt
    -RandomAccessFile if a file doesn't exist it will attempt to create it
    -RandomAccessFile has raf.seek(length not length-1 for last position) and raf.writeChars 
            valid modes are : new RandomAccessFile("file.txt", "rw"); r, rw, rws rwd    
    -if RandomAccessFile is expecting to read UTF use readUTF() and write using writeUTF()  -write and print methods of PrintWriter return void
    -none of the PrintWriter's methods throw any I/O exceptions because they supress the errors in writing and set an internal flag for error status instead.
        The checkError method returns true if there has been a problem in writing.
    -Path resolveSibling(Path other) :
        Resolves the given path against this path's parent path. This is useful where a file name needs to be replaced with another file name.
            Path.subpath(int beginIndex, int endIndex)
            1. Indexing starts from 0.
            2. Root (i.e. c:\) is not considered as the beginning.
            3. name at beginIndex is included but name at endIndex is not.
            4. paths do not start or end with \.
    -There is no toPath method; Path is an interface it cannot be instantiated.
    -Paths.get("/", "file.txt") joins strings into a path.
    -Path.subpath(from0Index, endExclusiveIndex).
    -Path.subpath(-1, 2), and path.subpath(1, 1), and path.subpath(2, 3) throw IllegalArgumentException.
    -subpath and getName dont include backslash
    -Files.readAllLines(path) returns List<String>
    -Files.lines(path) returns Stream<String>
    -Instances of the File class are immutable. Once created, the abstract pathname represented by a File object will never change.

### JPMS ### 

    -Overview
        -Basic Structure: module-info.java is mandatory and must at least declare the module's name.
        -modular JDK is divided of two kinds of modules - the standard modules (java.) and the non-standard modules (jdk.)
        -Module and Package Relationship: Modules contain packages, but packages don't contain or depend on modules.
        -Exports and Dependencies:
        -Only packages can be exported; individual classes cannot.
        -Dependencies are established at the module level, not on individual classes or packages.
        -The "uses" clause declares dependence on a service, while "requires" specifies dependence on a module.
        -"Requires transitive <module name>": Modules reading a module with this clause implicitly read the transitive module, avoiding the need for explicit declaration.
        -Service Usage: A module utilizing a service must require the module defining the service interface.
        -You cannot have more than one module in a directory. Although you may package a module into a jar, put multiple such module jars in a directory, and put that directory 
            (which contains multiple module jars) on the module path.
        -A modular jar can still be used like a regular jar. So, any non-modular application can use a modularized jar by putting that jar in the classpath just like any other jar.
        --cp, -classpath, and --class-path are equivalent options and the nonmodular jars should be put on classpath instead of module-path.
        -Bottom Up Approach for modularizing an application:
            Convert low-level libs into modular jars before high-level jars.
            Ex: an app main code in app.jar and uses datalayer.jar and mysql.jar. Low level libs are mysql.jar and then datalayer.
            For top-down approach, app.jar must be converted into a named module (module-info.java) requires datalayer and place datalayer on module path, mysql.jar on classpath.
        -You cannot have duplicate statements in module-info.java:
            exports com.amazing.movies; //1
            exports com.amazing.movies to com.amazing.rentals;// invalid conflict with //1
        -A module cannot access non-modular classes from the classpath. Convert non-modular third-party jar to an automatic module by putting that jar on module-path.
        -A module does not depend or belong to any package. Packages belong to a module.
        -module-info.java must not be empty.
        
        -Module Operations and Tools
            If you want to compile a module, then --module-source-path and -d options are required.
            Running Modules: Use --module-path and --module (e.g., java --module-path course.jar --module com.course.Main).
            Jmod Tool Options: Includes create, extract, list, describe, hash.
            Jdeps Tool: Analyzes dependencies of class files or JARs, specifying dependencies via --module-path, --class-path, or -cp.
                list all the modules on which moduleA depends, it will show an error if moduleA requires any other application module.
            -p is the short form for --module-path
            -m is the short form for --module 
            Structure of a module jar file is same as the regular jar file. It's possible to treat the jar file of a module as a regular jar file containing classes and 
                run a class that is present in the jar : java -classpath a.jar com.example.a.Main

    -Module Accessibility and Interactions
        -any non-modular application can simply add the modular jar on the classpath like any other non-modular jar.
        -Unnamed vs. Named Modules: Classes in unnamed modules can't be accessed by named modules.
        -Automatic Modules: They can access classes from all other modules.
        -Java modules do allow a service consumer to find a service implementation, however, it is not done using dependecy injection. 
            A service consumer has to loop through each available service implementation and pick the one it needs.
        -Direct Usage: If a module directly uses classes from another JAR, that JAR must be a named or automatic module.
        -Module Resolution: Use java --show-module-resolution to view module resolution during startup.
        -Module Source Path: The --module-source-path option in javac sets the location of module files (e.g., javac --module-source-path src -d out src/moduleA/a/A.java).
        -When adding a new abstract method to the service provider interface and calling it from the consumer module, you need to re-compile three specific modules:
            the service provider interface, the service provider, and the consumer module. The service locator module does not require re-compilation.
        -Command Line Customization: Although not recommended, package exports of a module can be customized via command-line options.
        --add-reads moduleA=moduleB: ModuleA reads all exported packages of moduleB.
        --add-exports moduleB/com.modB.package1=moduleA: ModuleB exports the package com.modB.package1 to moduleA.
        -any jar that you put on module-path is a named module, while any jar that you put on the classpath belongs to one "unnamed" module.
                Since the structure of a modular jar is same as a regular jar, it can still be used in the old manner.
        -java -classpath jar1.jar;jar2.jar com.abc.module.Main

### JDBC ### 

    Connection Management
        -JDBC URL Format: The standard format is jdbc:<subprotocol>:<subname>. This format helps in establishing a connection to the database.
            valid urls :
                -jdbc:oracle:thin:@localhost:1521:mydb
                -jdbc:mysql://192.168.1.10:3306/sample
                -jdbc:derby:1106:sample
        -AutoCommit Behavior: Using connection.setAutoCommit(true) commits the current transaction automatically.
        -Driver Registration (JDBC 4.0 and later): If the JDBC driver's JAR file is in the classpath, the driver is automatically registered.
            This simplifies the connection process, typically done via DriverManager.getConnection(url, userid, pwd).

    PreparedStatement and SQLException Handling
        Usage of setNull in PreparedStatement:
            For string types: ps.setString(4, null) is valid.
            For non-string types: Use ps.setNull(4, Types.XXX) (e.g., Types.INTEGER for integers). Using setNull with an incorrect SQL type may result in a SQLException.
        -Ensuring Parameter Setting: Failing to set parameters before executing a query will result in a SQLException.
        -Protection Against SQL Injection: PreparedStatement is preferred over Statement due to its inherent protection against SQL injection attacks.
        -Once a Connection object is closed, related objects like Statement and ResultSet, derived from that connection, become inaccessible.
        -PreparedStatement retains its parameter values until it is closed. 
        -If executing multiple times with the same values,there's no need to reset them each time.
   
    Statment methods: 
    -executeUpdate() returns the number of rows affected by the query.
    -execute() returns boolean : true if the first result is a ResultSet object; false if it is an update count or there are no results
    -executeQuery() returns ResultSet

    -In JDBC 4.0 : the drivers are loaded automatically based on the information provided by the driver's META-INF/services/java.sql.Driver file.
         No java code in necessary to load the driver classes.


### Enums ###

    -Interface Implementation: Enums can implement interfaces.
    -Declaration Order: Enum constants must be declared first in the enum type.
    -Constructor Visibility: Enum constructors are always implicitly private and cannot be public or protected.
    -Implicit Constructor: If no constructor is declared, an implicit private no-argument constructor is provided.
    -Final and Non-extendable: Enums are implicitly final, so they can't be extended or sealed, and they inherently extend java.lang.Enum.
    -Singleton Nature: Enums maintain a single instance of each constant, disallowing cloning (the clone method in java.lang.Enum is final).
    -Built-in Methods:
        values(): Returns an array of enum constants.
        valueOf(String): Returns the enum constant matching the string argument (case-sensitive) or throws IllegalArgumentException.
        ordinal(): Returns the constant's index (starting from 0).
        name(): Returns the enum constant's name as declared.
        toString() Method: By default, returns the enum's name, but it's overridable.
    -Comparable Implementation: Enums implement java.lang.Comparable, following the natural order of their ordinal values.
    -Definition Scope: Enums can be defined inside methods or constructors but without any access modifiers.
    -Field Access Restrictions: Non-final static fields cannot be accessed from an enum's constructor.


### Concurrency ### 

    -CopyOnWriteArrayList: A thread-safe variant of ArrayList. When the list is modified, it creates a fresh copy of the underlying array, making it ideal for environments with more reads than writes.
        Multiple threads can safely add and remove objects from CopyOnWriteArrayList simultaneously
    -java.util.concurrent API Usage: Commonly used for managing and coordinating concurrent tasks. Key components include Executors for thread pool management, 
        ConcurrentHashMap for concurrent hash maps, and CountDownLatch, CyclicBarrier, Semaphore for synchronization aids.
    -wait() vs sleep(): wait() releases the monitor lock allowing other threads to synchronize on the locked resource, while sleep() keeps the monitor lock, pausing the current thread without releasing any locks.
    -ConcurrentHashMap doesn't support null values
    -ConcurrentHashMap's putIfAbsent is atomic, while map.containsKey() is not.
    -AtomicIntegerer increment : ai.incrementAndGet() & ai.addAndGet(int);

    Multithreading issues : 
        -Deadlock: Occurs when two or more threads block forever, each waiting for the other to release a resource.
        -Livelock: A situation where threads are unable to make further progress, despite being active and not blocked, typically due to constantly responding to each other.
        -Thrashing: Occurs when a system spends more time processing task overhead than executing tasks, often seen in poor task or resource management.
        -Starvation: Happens when a thread is perpetually denied access to resources and unable to make progress.
        -Thread Safe Classes: Classes that are safe to use in a multithreaded environment, ensuring internal consistency and state when accessed by multiple threads. 
            Ex (Immutable classes, Vector, Hashtable, classes in java.util.concurrent).
    
    Identifying Threading Issues:
        -Look for deadlocks, livelocks, and race conditions.
        -Use thread dumps and monitoring tools.
        -Inspect code for common issues like improper synchronization and thread confinement violations.
    
    -UnsupportedOperationException: Thrown to indicate that a requested operation is not supported, often used in immutable collections or when an operation is not applicable for a specific class.
    -Worker Threads (Runnable/Callable): Threads that execute tasks. Runnable defines a task and Callable is similar but can return a result and throw checked exceptions.
    -Executor Service: A framework provided by the java.util.concurrent package to manage threads and tasks. It simplifies thread management and offers utilities like thread pools. Benefits include resource management, improved performance, and increased scalability.
    -When a synchronized method ends with a checked exception, the intrinsic lock held by the thread is released automatically.  
    -The intrinsic lock is released when the method ends. Irrespective of how it ends.
    -A thread acquires the intrinsic lock of an object when it enters synchronized method on that object or when it enter a synchronized block that uses that object. The lock is not acquired when a thread enters a non-synchronized method.

### Misc ###  

    Run the app : > javac src/main/java/run/Run.java && java -cp src/main/java/ run.Run


Other notes :
-record cannot be sealed and can implement a method that has a getter like the iface abstract method
-substring begin index start from 0 not 1
-exceptions don't enhance security by reporting errors, they improve code because of clearly
sparating error handling code from app main logic
-Collection.sort modifies the original list that is called on
-Optional.orElseGet() and orElse() doesn't throw an exception 
-Optional.of() throws a NullPointerException if the passed value is null
-A loader of a given service can be retrived by :
    -ServiceLoader<?> loader = ServiceLoader.load(?.class)
    -Once the service provider is loaded, iterate through it using :
        -for(? service: loader) service.serviceMethod(); 
            // java.util.ServiceLoader implements java.util.Iterable
        -Optional<?> service = loader.findFirst();
-There is no toPath method, Path is an interface it cannot be instanciated
-Paths.get("/", "file.txt") joins strings into a path
-Collectors.summarizingDouble(mappingFunc) = returns DoubleSummaryStatistics object containing getCount/Min/Max/Sum/Average
    getCount return long instead of double
-only one top level class can be in a single file (one visibility keyword)
    public class A  // ok
    class B  //ok
    class C  //ok
-connection.commit() to commit changes
-stream.forEach doesn't change the elements of the orginal list unlike map
-path.getName(0) doesn't return root (c:/ or /) it returns the 2nd element of path
-Bottom Up Approach for modularizing an application : 
    -convert low lovel libs into modular jars before high level jars
    -ex : an app main code in app.jar and uses datalayer.jar and mysql.jar   
        low level libs are mysql.jar and then datalayer
    -for topdown approach app.jar must be converted into named module (module-info.java)
        requires datalayer and place datalayer on module path, mysql.jar on classpath 
-jdeps --jdk-internals : uses static analysis to analyzes all classes of the given jar file 
    for class level dependence on jdk's internal API. 
    If any such dependence is found, it is printed with a suggestion for replacement.
-ls.stream().max(Comparator.comparing(a->a)).get(); max takes a comparator arg



2nd test :
-left operand of instanceof must be an object not a primitives
-anonymous classes are implicitly final and never statis
-you cannot override a final method
-append() method does not exist in String class
-The exception parameter in a multi-catch clause is implicitly final 
    catch (IOException | IndexOutOfBoundsException e)  'e' cannot be reassigned
-All the instance or static variables are given a default values 
    if they are not explicitly initialized.
-local variables must be initialized explicitly
-Locale locale = Locale.getDefault();
-DateFormat df = DateFormat.getDateInstance(); // doesn't take locale
-Correct streams :
    stream().parallel
    arrayList.parallelStream()
-you can compare unequal primitives double == Short, int == Long
    ype Promotion: Java automatically promotes smaller primitive types (like byte, short, char) to int or higher types as needed in comparisons.
Explicit Casting: When comparing an int to a long, explicit casting is required.
Wrapper Classes: Comparisons involving wrapper classes and primitives are valid as Java performs unboxing automatically.
No Implicit Promotion to long: Comparing int and long directly is invalid without explicit casting.
    -the wrapper object is first unboxed to its corresponding primitive type. 
    -Then, if necessary, type promotion occurs to match the types before the comparison.
- ? wildcard is valid on the right while instanciating but not on the left :
    HashMap<?, List<String>> box = new HashMap<String, List<String>>();


3rd test :
-TreeMap keys must be comparable, cannot add String and Double as keys in a generic TreeMap
-localDate.plus(Period.of(0, 1, 1)) // adds 1 month and 1 day, 
    Period.of(int year,int months, int days)
    localDate.plus(Period.ofMonths(1).ofDays(1)) will add only 1 day
-A thread can aquire a lock on the class
    -happens when a static synchronized method is invoked:
        since a static method is associated with a class 
        or acquire the lock on any class using a regular synchronized block
    -The intrinsic lock remains acquired throughout the duration of the synchronized method. 
-Instances of the File class are immutable. Once created, 
    the abstract pathname represented by a File object will never change.
-Exceptions thrown by autocloseable's close() are added to the original exception as suppressed exception
-stream().mapToDouble returns a DoubleStream instead of Stream<Double>
    use a DoubleBinaryOperator instead of BinaryOperator<Double> for reduction.
-You cannot have duplicate statments in module-info.java :
     exports com.amazing.movies; //1
     exports com.amazing.movies to com.amazing.rentals;// invalid conflict with //1
- / and * has the same precedence, expressions are evaluated from left to right 
    100/10*2 is 100 / 10 then * 2 (left to right)
-stream().sorted() require implementation of Comparable or Comparator otherwise ClassCastException is thrown
- module providing multiple implementations of an interface : 
    when a method of the interface is called 
-providing two implementations on an interface will lead to compiler error :
    use instead : provides iface with impl1, impl2
-service provider implementation must have a no args constructor
-binarySearch requires natural order sorted list to work 
     Collections.reverse(letters); will lead to unpredicatble return value/ undefined value
-ConcurrentHashMap putIfAbsent is atomic while map.containsKey() is not
-if and else do not cascade. They are like opening and closing braces. 
-Catch block cannot follow a finally block!
-When you split a Spliterator, the first half goes to the resulting 
    (new) Spliterator while the remaining half remains with the origininal one.
-Predicate must be typed or the param must be casted
-private interface methods can be static
-Static interface methods can be only called called using the interface name directly.
-Immutability of a record doesn't extend to the content of an Object of 
    record Student(int id,  Person person)  id and Person are immutable but the content of Person is not




another test:
-java type promotion hierarchy byte > short or chart > int > long > float > double > Object
    int is promoted to float not double
-null reference can be used to access a static variable withtout exception
-FileReader.read() throws FileNotFoundException if the file is not found
-path.subpath(from0Index, endExclusiveIndex)
-path.subpath(-1, 2) and  path.subpath(1, 1) and path.subpath(2, 3)throws IllegalArgumentException
-String.replace('str','str') returns a new string object but returns the same object if no change
    "String".replace('g','g') // no change same as "String"
    "hello".concat(" world").trim().equals("hello world") is true 
        trim() is useless, no space at the beginning or end of the string.
-instance methods can access both static and non static methods
-If finally block throws an exception the try exception is lost, it's not added to suppressed exception
-Strings from different packages represent the same object
-String s = this.toString(); is valid
-It is possible to deserialize the older objects into the update class objects even if the 
    original class did not explicitly define the serialVersionUID field.
-a module cannot access non-modular classes from the classpath. 
    You must convert non-modular third-party jar to an automatic module by putting that jar on module-path. 
-System.console() returns null if it's not available (code run in the background)
    so console.anyMethod() throws NPE
-pay attention to missing commas when initializing a 2D array
    int[][] array2D = new int[][] { { 0, 1, 2, 4} {5, 6}};
-valid array initialization :
    int[] arr = {1, 2};
    int[][] arr2 = {arr, {1, 2}, arr};
    int[][][] arr3 = {arr2};
-DecimalFormat has no constructor that takes a Locale
    use NumberFormat.getCurrencyInstance(locale)
    or DecimalFormat.getCurrencyInstance(locale)
-pay attention to FunctionalInterfaces input type String, Integer and if applyable on a List<Type>
-pay attention to predicate condition on takeWhile and dropWhile the stream may contain 0 element
-Files.readAllLines(path) returns a List<String> while Files.lines(path) returns a Stream<String>
-If a service provider has public static provider() method, 
    then it is not required for the service provider to be a subtype of the service type. 
    Only the provider method should return a subtype of the service type.
    ex :
        public static InterfaceToBeImplemented provider(){
            return new InterfaceToBeImplemented(){
                public List<String> filter(List<String> l) { return l; }
        };
   }
-If there is no provider method in the service provider class, then it must have a public no-args constructor.


